# -*- coding: utf-8 -*-
"""gan2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mmCpthoRIrnfeE1cpKhyGm5HxMMSfpv2
"""

import torch
import torch.nn as nn
import torch.nn.functional as F

class CompactDiscriminator(nn.Module):
    def __init__(self, voxel_dim=1, img_dim=3, hidden_dim=16):
        super(CompactDiscriminator, self).__init__()

        self.voxel_conv1 = nn.Conv3d(voxel_dim, hidden_dim, kernel_size=4, stride=2, padding=1)
        self.voxel_conv2 = nn.Conv3d(hidden_dim, hidden_dim * 2, kernel_size=4, stride=2, padding=1)
        self.voxel_conv3 = nn.Conv3d(hidden_dim * 2, hidden_dim * 4, kernel_size=4, stride=2, padding=1)

        self.img_conv1 = nn.Conv2d(img_dim, hidden_dim, kernel_size=4, stride=2, padding=1)
        self.img_conv2 = nn.Conv2d(hidden_dim, hidden_dim * 2, kernel_size=4, stride=2, padding=1)
        self.img_conv3 = nn.Conv2d(hidden_dim * 2, hidden_dim * 4, kernel_size=4, stride=2, padding=1)

    def forward(self, voxel, image):

        voxel_features = F.leaky_relu(self.voxel_conv1(voxel), 0.2)
        voxel_features = F.leaky_relu(self.voxel_conv2(voxel_features), 0.2)
        voxel_features = F.leaky_relu(self.voxel_conv3(voxel_features), 0.2)
        voxel_features = voxel_features.view(voxel_features.size(0), -1)

        img_features = F.leaky_relu(self.img_conv1(image), 0.2)
        img_features = F.leaky_relu(self.img_conv2(img_features), 0.2)
        img_features = F.leaky_relu(self.img_conv3(img_features), 0.2)
        img_features = img_features.view(img_features.size(0), -1)

        combined_features = torch.cat([voxel_features, img_features], dim=1)

        fc1 = nn.Linear(combined_features.size(1), 1024).to(combined_features.device)
        x = F.leaky_relu(fc1(combined_features), 0.2)
        
        fc2 = nn.Linear(1024, 512).to(combined_features.device)
        x = F.leaky_relu(fc2(x), 0.2)
        
        fc3 = nn.Linear(512, 1).to(combined_features.device)
        x = torch.sigmoid(fc3(x))

        return x

class CompactGenerator(nn.Module):
    def __init__(self, img_dim=3, hidden_dim=16, latent_dim=50):
        super(CompactGenerator, self).__init__()

        self.img_conv1 = nn.Conv2d(img_dim, hidden_dim, kernel_size=4, stride=2, padding=1)  # 64x64
        self.img_conv2 = nn.Conv2d(hidden_dim, hidden_dim * 2, kernel_size=4, stride=2, padding=1)  # 32x32
        self.img_conv3 = nn.Conv2d(hidden_dim * 2, hidden_dim * 4, kernel_size=4, stride=2, padding=1)  # 16x16

        img_feature_size = hidden_dim * 4 * 16 * 16

        # self.fc1 = nn.Linear(img_feature_size + latent_dim, img_feature_size // 2)
        self.fc1 = nn.Linear(img_feature_size + latent_dim, 64 * 4 * 4 * 4)

        #3d deconvolutionl layers for voxel gen.
        # self.deconv1 = nn.ConvTranspose3d(hidden_dim * 4, hidden_dim * 2, kernel_size=4, stride=2, padding=1)
        # self.deconv2 = nn.ConvTranspose3d(hidden_dim * 2, hidden_dim, kernel_size=4, stride=2, padding=1)
        # self.deconv3 = nn.ConvTranspose3d(hidden_dim, hidden_dim // 2, kernel_size=4, stride=2, padding=1)
        # self.deconv4 = nn.ConvTranspose3d(hidden_dim // 2, 1, kernel_size=3, stride=1, padding=1)
        self.deconv1 = nn.ConvTranspose3d(64, 32, kernel_size=4, stride=2, padding=1)
        self.deconv2 = nn.ConvTranspose3d(32, 16, kernel_size=4, stride=2, padding=1)
        self.deconv3 = nn.ConvTranspose3d(16, 8, kernel_size=4, stride=2, padding=1)
        self.deconv4 = nn.ConvTranspose3d(8, 1, kernel_size=3, stride=1, padding=1)

    def forward(self, img, z):
        img_features = F.leaky_relu(self.img_conv1(img), 0.2)
        img_features = F.leaky_relu(self.img_conv2(img_features), 0.2)
        img_features = F.leaky_relu(self.img_conv3(img_features), 0.2)

        img_features = img_features.view(img_features.size(0), -1)

        combined = torch.cat([img_features, z], dim=1)

        x = F.leaky_relu(self.fc1(combined), 0.2)

        x = x.view(x.size(0), 64, 4, 4, 4)

        x = F.leaky_relu(self.deconv1(x), 0.2)
        x = F.leaky_relu(self.deconv2(x), 0.2)
        x = F.leaky_relu(self.deconv3(x), 0.2)
        x = torch.sigmoid(self.deconv4(x))

        return x
